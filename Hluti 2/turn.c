#pragma config(Sensor, dgtl7,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393, openLoop)
#pragma config(Sensor, dgtl1, stopButton,     sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Tessi kodi inniheldur 4 foll. Tau eru oll logd saman til tess ad leysa volundarhus(keyra eftir uppgefnri leid) 2 follinn eru til tess ad resetta.
Eitt til ad reseta motorana annars vaeri erfitt at lata ta beygja og hitt til tess ad endurraesa encoderana til tess ad gildin verdi rett. Sidan er turn
fallid sem inniheldur kodanum til tess ad beygja baedi til haegri og vinstri. Eg tek inn 2 gildi. Eitt er gradunar sem eg vill beyga, hitt er i hvada att.
Robotinn minn virkadi tannig ad hann beygjdi mikid lengra til haegri en til vinstri tott ad eg var ad nota somu gildin. Tess vegna turfti eg ad utvega
mer breytu med annad gildi til tess ad beygja til haegri. Drive fallid tok eg ur fyrri verkefnum en tad er frekar einfalt og er til ad keyra Robotinn
afram */



/* Foll og breytur */
int BASEDIST = 564;
int BASEDEGleft = 3.2; /* D = 33cm, d = 10.16cm.... D/d = 3,2 */
int BASEDEGright = 2.0; /* Tad var ekki sama gildi her og fyrir hinn asinn. Dekkid var einhvad laust. Eg reyndi samt ad reikna gildid en tad gildi hentadi ekki */
int power = 80;

void reset(){
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
}
void stopMotors(){
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void turn(int deg, int beyga){
	if(beyga == 1){
		while(abs(SensorValue[rightEncoder]) < deg * BASEDEGleft){
			motor[leftMotor] = power * beyga;
			motor[rightMotor] = power * beyga;
		}
	}
	else{
		while(abs(SensorValue[rightEncoder]) < deg * BASEDEGright){
			motor[leftMotor] = power * beyga;
			motor[rightMotor] = power * beyga;
		}
	}
}
void drive(int dist){
	while(abs(SensorValue[rightEncoder]) < dist){
		motor[rightMotor] = power;
		motor[leftMotor] = -power;
	}
}

task stopMyTask(){
	while(SensorValue[stopButton] == 0 && vexRT[Btn8R]==0){
	}
	StopAllTasks();
}


/*-----------*/
/* KEYRSLA */

int beyga[14] = {1,-1,-1,1,1,-1,1,1,-1,1,1,-1,-1,1};



task main()
{
	StartTask(stopMyTask);
	wait1Msec(1000);
	for(int i = 0;i < 13;i++){
		wait1Msec(1000);
		reset();
		drive(BASEDIST);
		stopMotors();
		reset();
		wait1Msec(2000);
		turn(90, beyga[i]);
		stopMotors();
	}
	drive(BASEDIST);

}
